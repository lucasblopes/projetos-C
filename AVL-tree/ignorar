#include <stdio.h>
#include <stdlib.h>

#include "tree.h"

#define max(a,b) (((a)>(b))?(a):(b))

struct tNode *new_node(int key) {

    struct tNode *node = malloc(sizeof(struct tNode));
    if (!node) {
        perror("Error on malloc!\n");
        exit(1);
    }

    node->key = key;
    node->height = 0;
    node->parent = NULL;
    node->right = NULL;
    node->left = NULL;
    return node;
}

int height(struct tNode *p) {

    int hl, hr;

    if (!p)
        return -1;
    
    hl = height(p->left);
    hr = height(p->right);

    if(hl > hr)
        return hl+1;
    else
        return hr+1;
}

struct tNode *left_rotation(struct tNode *p) {

    struct tNode* q = p->right;

    p->right = q->left;
    q->parent = p->parent;
    p->parent = q;

    if (q->left)
        q->left->parent = p;

    q->left = p;

    /* atualiza as alturas quando rotacionar */
    q->height = height(q);
    p->height = height(p);

    return q;
}

struct tNode *right_rotation(struct tNode *p) {

    struct tNode *q = p->left;

    p->left = q->right;
    q->parent = p->parent;
    p->parent = q;

    if (q->right)
        q->right->parent = p;

    q->right = p;
    
    /* atualiza as alturas quando rotacionar */
    q->height = height(q);
    p->height = height(p);

    return q;
}

/* retorna a diferenca de nivel do nodo esquerdo e do direito, de um pai */
int balance_factor(struct tNode* p) {

    if (!p)
        return 0;

    return height(p->left) - height(p->right);
}

struct tNode *node_remove(struct tNode *node, struct tNode *root) {

    struct tNode *new_root = root, *s; /* successor */

    if(!node->left) {
        transplant(node, node->right);
        free(node);
    } 
    else {
    if (!node->right) {
        transplant(node, node->left);
        free(node);
    } else {
        s = minimum_value(node->right);
        transplant(s, s->right);
        s->left = node->left;
        s->right = node->right;
        transplant(node, s);
        if (node == root)
            new_root = s;
        free(node);
        }
    }
    return new_root;
}

/* verifica se a árvore está equilibrada e realiza rotações, se necessário */
    bf = balance_factor(new_root);
    if (bf > 1) {
        if (balance_factor(new_root->left) < 0)
            new_root->left = left_rotation(new_root->left);
        new_root = right_rotation(new_root);
    }
    else if (bf < -1) {
        if (balance_factor(new_root->right) > 0)
            new_root->right = right_rotation(new_root->right);
        new_root = left_rotation(new_root);
    }


/* Verifica se o nó a ser removido é a raiz e se possui filhos */
    if (root->key == key && root->left && root->right) {
        /* Busca o sucessor do nó raiz */
        s = min_node(root->right);
        /* Troca o valor da raiz pelo valor do sucessor */
        root->key = s->key;
        /* Remove o sucessor da subárvore direita */
        root->right = node_remove(root->right, s->key);
        /* Atualiza a altura do nó raiz */
        root->height = height(root);
        /* Realiza o balanceamento da árvore */
        root = tree_balance(root);
        return root;
    }

    struct tNode *node_remove(struct tNode *node, int key) {

    struct tNode *parent = node->parent, *s; /* successor */

    if (node->key == key) {
        if (!node->left && !node->right) { /* caso 1: nodo nao tem filhos */
            if (!parent) { /* caso especial: remover a raiz */
                node = NULL;
                return node;
            }
            if (parent->left == node)
                parent->left = NULL;
            else 
                parent->right = NULL;
            free(node);
        } else
        if (!node->left || !node->right) { /* caso 2: nodo tem apenas um filho */
            if (!parent) {  /* caso especial: remover a raiz */
                if (node->left) {
                    node->left->parent = NULL;
                    free(node);
                    return node->left;
                } else {
                    node->right->parent = NULL;
                    free(node);
                    return node->right;
                }
            } else {
                if (node->left) {
                    if (parent->left == node)
                        parent->left = node->left;
                    else  
                        parent->right = node->left;
                    node->left->parent = parent;    
                } else {
                    if (parent->left == node)
                        parent->left = node->left;
                    else 
                        parent->right = node->left;
                    node->right->parent = parent;
                }
                free(node);
            }
            } else { /* caso 3: nodo tem os 2 filhos */
                s = min_node(node->right);
                s->right->parent = s->parent;
                s->right = node->right;
                s->left = node->left;
                node->left->parent = s;
                node->right->parent = s;
                if (!parent)
                    s->parent = NULL;
                else {
                    if (parent->left == node)
                        parent->left = s;
                    else 
                        parent->right = s;
                }
                free(node);
            }
    } else {
        if (key < node->key)
            node->left = node_remove(node->left, key);
        else
            node->right = node_remove(node->right, key);
    }

    parent->height = height(parent);
    parent = tree_balance(parent);

    return parent;
}